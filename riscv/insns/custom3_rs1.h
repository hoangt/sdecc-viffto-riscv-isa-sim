reg_t msg = p->get_csr(CSR_PENALTY_BOX_MSG);
reg_t cl[8];
cl[0] = p->get_csr(CSR_PENALTY_BOX_CACHELINE_BLK0);
cl[1] = p->get_csr(CSR_PENALTY_BOX_CACHELINE_BLK1);
cl[2] = p->get_csr(CSR_PENALTY_BOX_CACHELINE_BLK2);
cl[3] = p->get_csr(CSR_PENALTY_BOX_CACHELINE_BLK3);
cl[4] = p->get_csr(CSR_PENALTY_BOX_CACHELINE_BLK4);
cl[5] = p->get_csr(CSR_PENALTY_BOX_CACHELINE_BLK5);
cl[6] = p->get_csr(CSR_PENALTY_BOX_CACHELINE_BLK6);
cl[7] = p->get_csr(CSR_PENALTY_BOX_CACHELINE_BLK7);
reg_t blockpos = p->get_csr(CSR_PENALTY_BOX_CACHELINE_BLKPOS);
uint8_t victim_message[8];
memcpy(victim_message, &msg, 8);
uint8_t cacheline[64];
memcpy(cacheline, cl, 64);
std::string script_filename = "/home/mgottscho/Git/eccgrp-ecc-ctrl/data_recovery_spike_wrapper.sh";
std::string cmd = construct_sdecc_recovery_cmd(script_filename, victim_message, 8, cacheline, (unsigned)(blockpos));
std::string output = myexec(cmd);
std::cout << output << std::endl;
const char* output_cstr = output.c_str();
//memcpy((void*)RS1, output_cstr, output.length());
MMU.store_slow_path(RS1, output.length(), (const uint8_t*)output_cstr, 0);
